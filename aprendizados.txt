O SQLModel usa o nome das classes que declaramos como tabel = True para o nome das tabelas 
ex:
class Personagem => o nome da tabela sera personagem 
Evento => evento 
E assim por diante...

Caso quissese dar um nome a tabela diferente da classe usaria 
class Personagem(SQLModel, table=True):
    __tablename__ = "herois"  => aqui voce coloca o nome que deseja dar a tabela 


âœ¨ Dicas rÃ¡pidas para nÃ£o esquecer:
Relationship(...): Ã© o elo com outra tabela. Ele te dÃ¡ acesso ao(s) objeto(s) relacionados.

back_populates="...": sempre aponta pro nome do campo do outro lado da conexÃ£o (espelho da relaÃ§Ã£o).

List[...]: indica que o campo guarda vÃ¡rios registros relacionados (porque o relacionamento Ã© do tipo N:N).

Optional[...] + = None (em outros campos): permitem que aquele campo seja preenchido ou nÃ£o â€” ou seja, nÃ£o obrigatÃ³rio.


âœ… 1. O Relationship funciona sem o campo personagem_id?
Tecnicamente, nÃ£o. O Relationship precisa de uma foreign key pra funcionar corretamente. Ele nÃ£o faz mÃ¡gica sozinho â€” ele depende da chave estrangeira declarada com Field(foreign_key=...) pra saber como conectar as tabelas.

Exemplo:

personagem_id: int = Field(foreign_key="personagem.id")

Essa linha:

Cria o vÃ­nculo entre a tabela atual e a tabela personagem

Permite que o Relationship(...) entenda: â€œAh! Esse ID aqui corresponde ao id lÃ¡ na tabela personagem.â€

ğŸ” Ou seja: > O Relationship sozinho nÃ£o conecta nada sem a presenÃ§a da chave estrangeira (ForeignKey).

Nem sempre precisamos usar o back_populates no entanto faz muito mais sentido usar pois ele permite que possamos navegar de um lado para o outro nas 
tabelas assim as consultas ficam mais consistentes 



ğŸ§± O que Ã© Field() afinal?
O Field() Ã© uma funÃ§Ã£o fornecida pelo SQLModel (que na real vem do Pydantic/SQLAlchemy) que permite configurar detalhes extras de um campo, como:

TornÃ¡-lo uma chave primÃ¡ria

Definir valores padrÃ£o

Adicionar validaÃ§Ãµes, restriÃ§Ãµes, descriÃ§Ãµes

Dizer que aquele campo Ã© uma foreign key (chave estrangeira)

ğŸ› ï¸ JÃ¡ campos simples como nome: str, historia: Optional[str]...
Esses sÃ£o campos que nÃ£o precisam de nada especial alÃ©m do tipo. EntÃ£o podem ser declarados direto, sem o Field(). Exemplo:

python
nome: str  # Simples, obrigatÃ³rio
historia: Optional[str] = None  # Opcional, com valor padrÃ£o
O SQLModel jÃ¡ entende o tipo, se Ã© obrigatÃ³rio ou nÃ£o, e qual Ã© o valor padrÃ£o sÃ³ por essa sintaxe.

Tipo de campo	Precisa de Field()?	Por quÃª?
Simples, como str, int	âŒ NÃ£o	O tipo + valor padrÃ£o jÃ¡ sÃ£o suficientes
Chave primÃ¡ria	âœ… Sim	Precisa dizer que Ã© primary_key=True
Chave estrangeira	âœ… Sim	Precisa de foreign_key="..."
Quer definir metadata extra	âœ… Sim	Ex: description=, max_length=, etc



Porque usamos o default = None na criaÃ§Ã£o de primary keys
1. ğŸ§  O id Ã© gerado automaticamente pelo banco
Quando usamos primary_key=True no SQLModel e nÃ£o passamos valor para o id ao criar o objeto, o banco de dados cuida disso pra gente (auto-incremento).

Mas o Python precisa receber algum valor ali na criaÃ§Ã£o do objeto, e se nÃ£o tiver = None, ele vai reclamar que estÃ¡ faltando o campo.

â¡ï¸ Por isso dizemos: "Este campo Ã© opcional e comeÃ§a como None, porque o banco vai preenchÃª-lo pra mim."




Os SCHEMAS:
schemas = Camadas de validaÃ§Ã£o e entrada/saÃ­da de dados
Entrada de dados (POST)	Define o que o usuÃ¡rio pode ou deve enviar ao cadastrar algo
SaÃ­da de dados (GET)	Define o que a API devolve ao listar/mostrar um objeto
schemas = Camadas de validaÃ§Ã£o e entrada/saÃ­da de dados


DEPENDS
Pega uma funÃ§Ã£o e seu retorno e passa como parametro em uma outra funÃ§Ã£o 

SESSION
session : Session Ã© so para indicar que session Ã© do tipo sessÃ£o 
âš¡ Resumo mÃ¡gico:
Parte do cÃ³digo	O que faz?
Depends(get_session)	Chama a funÃ§Ã£o get_session() e injeta o resultado
session: Session = Depends(...)	Diz: â€œesse parÃ¢metro vai receber algo do tipo Sessionâ€



ğŸŒ Estrutura da API com FastAPI + SQLModel
ğŸ”§ Arquitetura
models/: Onde ficam os modelos do banco (com table=True)

schemas/: Modelos de entrada/saÃ­da com BaseModel (validaÃ§Ã£o e controle)

routes/: Arquivos com as rotas da API (agrupadas por recurso)

database.py: Onde Ã© criada a engine e a funÃ§Ã£o get_session()

main.py: Ponto inicial da aplicaÃ§Ã£o (instÃ¢ncia do FastAPI, rotas, criaÃ§Ã£o do banco)

ğŸ§± SQLModel e Field(...)
Field(...) Ã© usado quando:

Define PK: primary_key=True

Define FK: foreign_key="tabela.coluna"

Define valor padrÃ£o ou metadados extras (default=, description=, etc)

Exemplo:

python
id: Optional[int] = Field(default=None, primary_key=True)
ğŸ”— Relacionamentos (Relationship())
âœ”ï¸ Um-para-muitos e Muitos-para-muitos:
Use Relationship() com back_populates espelhando o nome do campo do outro lado.

âœ”ï¸ Quando hÃ¡ duas FKs para a mesma tabela:
Use sa_relationship_kwargs={"foreign_keys": "[Classe.campo]"} para evitar ambiguidade.

ğŸ§  InjeÃ§Ã£o de DependÃªncias com Depends
O que Ã©?
O FastAPI chama automaticamente funÃ§Ãµes auxiliares (como get_session()) e injeta o resultado como argumento da funÃ§Ã£o de rota.

Exemplo:

python
def get_session():
    return Session(engine)

@router.get("/")
def listar(session: Session = Depends(get_session)):
    ...
ğŸ“¤ Rotas com FastAPI
Criando um personagem:
python
@router.post("/", status_code=201)
def criar(dados: PersonagemCreate, session: Session = Depends(get_session)):
    novo = Personagem(**dados.dict())
    session.add(novo)
    session.commit()
    session.refresh(novo)
    return novo
Listando todos os personagens:
python
@router.get("/", response_model=List[Personagem])
def listar(session: Session = Depends(get_session)):
    return session.query(Personagem).all()
ğŸ§© Tipagem e clareza
session: Session: Ã© anotaÃ§Ã£o de tipo

Facilita autocomplete, documentaÃ§Ã£o Swagger e leitura

List[Objeto]: indica que a rota retorna uma lista de objetos daquele tipo

Optional[str] = None: campo opcional com valor padrÃ£o

ğŸ› ï¸ Dicas bÃ´nus
Sempre importe seus models no main.py pra garantir que as tabelas sejam registradas e criadas com create_all()

Nunca repita o nome de um campo (conflitos) em dois lugares com tipos diferentes

Use TYPE_CHECKING quando quiser evitar importaÃ§Ãµes circulares entre modelos

Se quiser, posso gerar isso num .md, .txt ou atÃ© transformar em pÃ¡gina bonita explicativa depois ğŸ˜„

Prontinha pra prÃ³xima aventura? Vamos codar mais uma funcionalidade? ğŸš€ğŸ’»ğŸ“˜


**dados.dict()	Converte um schema em argumentos para criar objeto ORM
response_model=List[...]	Define o formato da resposta da rota
session.query(Model).all()	Consulta todos os registros de uma tabela do banco


Isso aÃ­ Ã© a essÃªncia do que tÃ¡ rolando na linha Evento(**dados.dict()). Bora sÃ³ reforÃ§ar com uma explicaÃ§Ã£o bem visual pra cravar de vez esse entendimento:

ğŸš¦ Fluxo completo, passo a passo
UsuÃ¡rio envia JSON no corpo da requisiÃ§Ã£o:

json
{
  "nome": "Davi Ã© coroado",
  "descricao": "UnÃ§Ã£o como rei de Israel"
}
FastAPI converte esse JSON num objeto EventoCreate (um schema Pydantic):

python
dados = EventoCreate(nome="Davi Ã© coroado", descricao="UnÃ§Ã£o como rei")
.dict() converte esse objeto num dicionÃ¡rio Python:

python
{
  "nome": "Davi Ã© coroado",
  "descricao": "UnÃ§Ã£o como rei"
}
** desempacota o dicionÃ¡rio em argumentos nomeados:

python
Evento(nome="Davi Ã© coroado", descricao="UnÃ§Ã£o como rei")
ğŸ”„ Esse objeto Evento Ã© do tipo SQLModel, pronto pra ser salvo com:

python
session.add(novo)
session.commit()
ğŸ§ª TraduÃ§Ã£o mental da linha:
python
novo = Evento(**dados.dict())
â€œCrie um novo Evento, usando os campos recebidos da requisiÃ§Ã£o como argumentos nomeados.â€


Schemas entrada e saida de dados
Consultar uma informaÃ§Ã£o Ã© no banco de dados 



06/07/25 - duvidas 
- o que seria um token do tipo bearer? - quando uma funÃ§Ã£o tem essa sintaxe por exemplo : "-> str" significa que ela vai retornar o tipo que esta na frente 
da setinha? nesse caso um string 

- pq precisamos decodificar o token? - o que de fato o token guarda nele? 

- o que essa linha faz? oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/login") 

- pq payload? 

- essa parte pega o horario do momento em que o token Ã© gerado? datetime.utcnow()

- pq precisamos copiar os dados e nao so usar eles como vem? dados_para_token = dados.copy()

 - o que jwt.encode e decode significa?

 respostas as duvidas:

 ğŸ” 1. O que Ã© um token do tipo Bearer?
Bearer Ã© um tipo de token de autenticaÃ§Ã£o usado em APIs. Quando o cliente (frontend ou Postman) envia uma requisiÃ§Ã£o para uma rota protegida, ele envia o token assim:

Authorization: Bearer <seu_token_aqui>
â€œBearerâ€ significa literalmente â€œportadorâ€

A API entende: â€œquem estÃ¡ portando esse token tem permissÃ£o para acessarâ€

â¡ï¸ 2. O que significa -> str?
Sim! Isso Ã© uma anotaÃ§Ã£o de tipo em Python.

python
def criar_token_jwt(dados: dict) -> str:
Significa:

â€œEssa funÃ§Ã£o recebe um dict e retorna uma str.â€

Ã‰ sÃ³ uma dica para o desenvolvedor (e para ferramentas como o VS Code), nÃ£o muda o comportamento da funÃ§Ã£o.

ğŸ”“ 3. Por que precisamos decodificar o token?
Porque o token JWT Ã© uma string codificada com informaÃ§Ãµes dentro. Quando o usuÃ¡rio envia o token, precisamos ler o que tem dentro dele â€” como o ID do usuÃ¡rio, por exemplo.

Sem decodificar, ele seria sÃ³ uma sequÃªncia de caracteres ilegÃ­vel como:

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
ğŸ“¦ 4. O que o token guarda dentro dele?
Um token JWT guarda um â€œpacoteâ€ de informaÃ§Ãµes chamado payload. No nosso caso, ele guarda:

json
{
  "sub": "5",         // ID do usuÃ¡rio
  "exp": 1720000000   // Data de expiraÃ§Ã£o (timestamp)
}
VocÃª pode guardar o que quiser dentro do token (com moderaÃ§Ã£o), mas o mais comum Ã©:

sub â†’ subject (quem Ã© o dono do token)

exp â†’ expiration (quando o token expira)

ğŸ” 5. O que faz essa linha?
python
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/login")
Ela cria um â€œesquema de autenticaÃ§Ã£oâ€ que:

Espera um token do tipo Bearer no cabeÃ§alho

Usa a URL /login como ponto de entrada para obter o token

Depois, vocÃª usa isso em qualquer rota com:

python
token: str = Depends(oauth2_scheme)
E ele automaticamente extrai o token da requisiÃ§Ã£o.

ğŸ“¦ 6. Por que o nome payload?
â€œPayloadâ€ Ã© um termo comum em computaÃ§Ã£o que significa:

â€œA carga Ãºtil de uma mensagemâ€ â€” ou seja, o conteÃºdo real que importa.

No JWT, o payload Ã© a parte que guarda os dados do usuÃ¡rio (como o ID).

ğŸ•’ 7. O que faz datetime.utcnow()?
Sim! Ele pega a data e hora atual em UTC (tempo universal coordenado). Usamos isso para definir quando o token vai expirar:

python
expiracao = datetime.utcnow() + timedelta(minutes=60)
Ou seja: o token vai expirar em 60 minutos a partir de agora.

ğŸ“‹ 8. Por que usamos dados.copy()?
Porque vamos modificar o dicionÃ¡rio original adicionando a expiraÃ§Ã£o:

python
dados_para_token = dados.copy()
dados_para_token.update({"exp": expiracao})
Se usÃ¡ssemos o dados original diretamente, estarÃ­amos alterando o dicionÃ¡rio original que foi passado â€” o que pode causar efeitos colaterais indesejados.

ğŸ” 9. O que significam jwt.encode e jwt.decode?
Essas sÃ£o as funÃ§Ãµes da biblioteca python-jose que:

jwt.encode(...) â†’ transforma um dicionÃ¡rio em um token JWT (string)

jwt.decode(...) â†’ lÃª um token JWT e extrai o dicionÃ¡rio original

Exemplo:

python
token = jwt.encode({"sub": "5"}, SECRET_KEY, algorithm="HS256")
# token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

dados = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
# dados = {"sub": "5"}



porque preciso tranformar em string o id para mandar para o token ?  token = criar_token_jwt({"sub":str(usuario.id)})
ğŸ” Por que usamos str(usuario.id) no token?
A resposta curta Ã©: porque o JWT espera que os valores no payload sejam serializÃ¡veis em JSON â€” e o JSON sÃ³ aceita strings como chaves e valores simples como str, int, bool, etc.

ğŸ§  O que Ã© o sub?
sub Ã© uma convenÃ§Ã£o no JWT que significa subject (quem Ã© o dono do token)

Ele pode ser qualquer identificador Ãºnico do usuÃ¡rio

A especificaÃ§Ã£o do JWT recomenda que seja uma string

ğŸ”§ O que acontece se vocÃª mandar um int?
Na prÃ¡tica, o jwt.encode() atÃ© aceita um int como valor. Mas ao fazer isso:

python
token = criar_token_jwt({"sub": usuario.id})  # int
VocÃª pode acabar com inconsistÃªncias depois, por exemplo:

Ao decodificar, o valor pode vir como string dependendo da lib

ComparaÃ§Ãµes como int(payload["sub"]) == usuario.id podem falhar se nÃ£o forem tratadas

âœ… Por isso usamos:
python
token = criar_token_jwt({"sub": str(usuario.id)})
E depois, ao decodificar:

python
usuario_id = int(payload["sub"])
Assim vocÃª garante:

Que o token Ã© compatÃ­vel com o padrÃ£o JWT

Que o valor pode ser convertido de volta com seguranÃ§a

ğŸ§ª Exemplo
python
# No login
token = criar_token_jwt({"sub": "5"})  # string

# Depois, ao usar o token
payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
usuario_id = int(payload["sub"])  # converte de volta pra int
âœ… Em resumo
| Por quÃª? | Porque o JWT espera strings no payload, e sub Ã© uma string por convenÃ§Ã£o | | O que ganhamos? | Compatibilidade, clareza e seguranÃ§a na hora de decodificar |


Arrumando importaÃ§Ã£o circular 
.

ğŸ§  Em resumo:
O que fazer	Como
Evitar import circular	Use "NomeDaClasse" como string
Evitar from ... import ... no topo	FaÃ§a o import no final do arquivo
SQLModel entende isso?	Sim, perfeitamente!

FaÃ§a a importaÃ§Ã£o tardia em apenas um dos arquivos sendo ele aquele que precisa realmente acessar a outra classe diretamente (sem usar string).

ğŸ§  Como decidir onde fazer a importaÃ§Ã£o tardia?
âœ… Use "NomeDaClasse" como string nos dois arquivos:
Isso jÃ¡ resolve o problema de referÃªncia circular para o SQLModel.

ğŸ” Mas se vocÃª precisar usar a classe diretamente (ex: para tipagem, validaÃ§Ã£o, ou testes), aÃ­ sim vocÃª faz a importaÃ§Ã£o tardia no final do arquivo.
ğŸ“Œ No seu caso:
Em quiz.py:
VocÃª pode deixar assim:

python
perguntas: List["Pergunta"] = Relationship(back_populates="quiz")
E no final do arquivo:

python
from app.models.pergunta import Pergunta  # â† importaÃ§Ã£o tardia aqui
Em pergunta.py:
VocÃª tambÃ©m pode usar:

python
quiz: Optional["Quiz"] = Relationship(back_populates="perguntas")
E nÃ£o precisa importar Quiz diretamente se nÃ£o estiver usando ela fora do relacionamento.

âœ… ConclusÃ£o
Arquivo	ImportaÃ§Ã£o tardia necessÃ¡ria?	Por quÃª?
quiz.py	âœ… Sim	Porque ele precisa saber o que Ã© Pergunta para o relacionamento funcionar
pergunta.py	âŒ NÃ£o	SÃ³ usa "Quiz" como string, o que jÃ¡ Ã© suficiente

Declarar primeiro a logica estatica depois a dinamica (lembrar do que aconteceu com emblemas)