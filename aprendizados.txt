O SQLModel usa o nome das classes que declaramos como tabel = True para o nome das tabelas 
ex:
class Personagem => o nome da tabela sera personagem 
Evento => evento 
E assim por diante...

Caso quissese dar um nome a tabela diferente da classe usaria 
class Personagem(SQLModel, table=True):
    __tablename__ = "herois"  => aqui voce coloca o nome que deseja dar a tabela 


‚ú® Dicas r√°pidas para n√£o esquecer:
Relationship(...): √© o elo com outra tabela. Ele te d√° acesso ao(s) objeto(s) relacionados.

back_populates="...": sempre aponta pro nome do campo do outro lado da conex√£o (espelho da rela√ß√£o).

List[...]: indica que o campo guarda v√°rios registros relacionados (porque o relacionamento √© do tipo N:N).

Optional[...] + = None (em outros campos): permitem que aquele campo seja preenchido ou n√£o ‚Äî ou seja, n√£o obrigat√≥rio.


‚úÖ 1. O Relationship funciona sem o campo personagem_id?
Tecnicamente, n√£o. O Relationship precisa de uma foreign key pra funcionar corretamente. Ele n√£o faz m√°gica sozinho ‚Äî ele depende da chave estrangeira declarada com Field(foreign_key=...) pra saber como conectar as tabelas.

Exemplo:

personagem_id: int = Field(foreign_key="personagem.id")

Essa linha:

Cria o v√≠nculo entre a tabela atual e a tabela personagem

Permite que o Relationship(...) entenda: ‚ÄúAh! Esse ID aqui corresponde ao id l√° na tabela personagem.‚Äù

üîÅ Ou seja: > O Relationship sozinho n√£o conecta nada sem a presen√ßa da chave estrangeira (ForeignKey).

Nem sempre precisamos usar o back_populates no entanto faz muito mais sentido usar pois ele permite que possamos navegar de um lado para o outro nas 
tabelas assim as consultas ficam mais consistentes 



üß± O que √© Field() afinal?
O Field() √© uma fun√ß√£o fornecida pelo SQLModel (que na real vem do Pydantic/SQLAlchemy) que permite configurar detalhes extras de um campo, como:

Torn√°-lo uma chave prim√°ria

Definir valores padr√£o

Adicionar valida√ß√µes, restri√ß√µes, descri√ß√µes

Dizer que aquele campo √© uma foreign key (chave estrangeira)

üõ†Ô∏è J√° campos simples como nome: str, historia: Optional[str]...
Esses s√£o campos que n√£o precisam de nada especial al√©m do tipo. Ent√£o podem ser declarados direto, sem o Field(). Exemplo:

python
nome: str  # Simples, obrigat√≥rio
historia: Optional[str] = None  # Opcional, com valor padr√£o
O SQLModel j√° entende o tipo, se √© obrigat√≥rio ou n√£o, e qual √© o valor padr√£o s√≥ por essa sintaxe.

Tipo de campo	Precisa de Field()?	Por qu√™?
Simples, como str, int	‚ùå N√£o	O tipo + valor padr√£o j√° s√£o suficientes
Chave prim√°ria	‚úÖ Sim	Precisa dizer que √© primary_key=True
Chave estrangeira	‚úÖ Sim	Precisa de foreign_key="..."
Quer definir metadata extra	‚úÖ Sim	Ex: description=, max_length=, etc



Porque usamos o default = None na cria√ß√£o de primary keys
1. üß† O id √© gerado automaticamente pelo banco
Quando usamos primary_key=True no SQLModel e n√£o passamos valor para o id ao criar o objeto, o banco de dados cuida disso pra gente (auto-incremento).

Mas o Python precisa receber algum valor ali na cria√ß√£o do objeto, e se n√£o tiver = None, ele vai reclamar que est√° faltando o campo.

‚û°Ô∏è Por isso dizemos: "Este campo √© opcional e come√ßa como None, porque o banco vai preench√™-lo pra mim."




Os SCHEMAS:
schemas = Camadas de valida√ß√£o e entrada/sa√≠da de dados
Entrada de dados (POST)	Define o que o usu√°rio pode ou deve enviar ao cadastrar algo
Sa√≠da de dados (GET)	Define o que a API devolve ao listar/mostrar um objeto
schemas = Camadas de valida√ß√£o e entrada/sa√≠da de dados