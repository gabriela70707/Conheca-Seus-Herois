O SQLModel usa o nome das classes que declaramos como tabel = True para o nome das tabelas 
ex:
class Personagem => o nome da tabela sera personagem 
Evento => evento 
E assim por diante...

Caso quissese dar um nome a tabela diferente da classe usaria 
class Personagem(SQLModel, table=True):
    __tablename__ = "herois"  => aqui voce coloca o nome que deseja dar a tabela 


✨ Dicas rápidas para não esquecer:
Relationship(...): é o elo com outra tabela. Ele te dá acesso ao(s) objeto(s) relacionados.

back_populates="...": sempre aponta pro nome do campo do outro lado da conexão (espelho da relação).

List[...]: indica que o campo guarda vários registros relacionados (porque o relacionamento é do tipo N:N).

Optional[...] + = None (em outros campos): permitem que aquele campo seja preenchido ou não — ou seja, não obrigatório.


✅ 1. O Relationship funciona sem o campo personagem_id?
Tecnicamente, não. O Relationship precisa de uma foreign key pra funcionar corretamente. Ele não faz mágica sozinho — ele depende da chave estrangeira declarada com Field(foreign_key=...) pra saber como conectar as tabelas.

Exemplo:

personagem_id: int = Field(foreign_key="personagem.id")

Essa linha:

Cria o vínculo entre a tabela atual e a tabela personagem

Permite que o Relationship(...) entenda: “Ah! Esse ID aqui corresponde ao id lá na tabela personagem.”

🔁 Ou seja: > O Relationship sozinho não conecta nada sem a presença da chave estrangeira (ForeignKey).

Nem sempre precisamos usar o back_populates no entanto faz muito mais sentido usar pois ele permite que possamos navegar de um lado para o outro nas 
tabelas assim as consultas ficam mais consistentes 



🧱 O que é Field() afinal?
O Field() é uma função fornecida pelo SQLModel (que na real vem do Pydantic/SQLAlchemy) que permite configurar detalhes extras de um campo, como:

Torná-lo uma chave primária

Definir valores padrão

Adicionar validações, restrições, descrições

Dizer que aquele campo é uma foreign key (chave estrangeira)

🛠️ Já campos simples como nome: str, historia: Optional[str]...
Esses são campos que não precisam de nada especial além do tipo. Então podem ser declarados direto, sem o Field(). Exemplo:

python
nome: str  # Simples, obrigatório
historia: Optional[str] = None  # Opcional, com valor padrão
O SQLModel já entende o tipo, se é obrigatório ou não, e qual é o valor padrão só por essa sintaxe.

Tipo de campo	Precisa de Field()?	Por quê?
Simples, como str, int	❌ Não	O tipo + valor padrão já são suficientes
Chave primária	✅ Sim	Precisa dizer que é primary_key=True
Chave estrangeira	✅ Sim	Precisa de foreign_key="..."
Quer definir metadata extra	✅ Sim	Ex: description=, max_length=, etc



Porque usamos o default = None na criação de primary keys
1. 🧠 O id é gerado automaticamente pelo banco
Quando usamos primary_key=True no SQLModel e não passamos valor para o id ao criar o objeto, o banco de dados cuida disso pra gente (auto-incremento).

Mas o Python precisa receber algum valor ali na criação do objeto, e se não tiver = None, ele vai reclamar que está faltando o campo.

➡️ Por isso dizemos: "Este campo é opcional e começa como None, porque o banco vai preenchê-lo pra mim."




Os SCHEMAS:
schemas = Camadas de validação e entrada/saída de dados
Entrada de dados (POST)	Define o que o usuário pode ou deve enviar ao cadastrar algo
Saída de dados (GET)	Define o que a API devolve ao listar/mostrar um objeto
schemas = Camadas de validação e entrada/saída de dados


DEPENDS
Pega uma função e seu retorno e passa como parametro em uma outra função 

SESSION
session : Session é so para indicar que session é do tipo sessão 
⚡ Resumo mágico:
Parte do código	O que faz?
Depends(get_session)	Chama a função get_session() e injeta o resultado
session: Session = Depends(...)	Diz: “esse parâmetro vai receber algo do tipo Session”



🌐 Estrutura da API com FastAPI + SQLModel
🔧 Arquitetura
models/: Onde ficam os modelos do banco (com table=True)

schemas/: Modelos de entrada/saída com BaseModel (validação e controle)

routes/: Arquivos com as rotas da API (agrupadas por recurso)

database.py: Onde é criada a engine e a função get_session()

main.py: Ponto inicial da aplicação (instância do FastAPI, rotas, criação do banco)

🧱 SQLModel e Field(...)
Field(...) é usado quando:

Define PK: primary_key=True

Define FK: foreign_key="tabela.coluna"

Define valor padrão ou metadados extras (default=, description=, etc)

Exemplo:

python
id: Optional[int] = Field(default=None, primary_key=True)
🔗 Relacionamentos (Relationship())
✔️ Um-para-muitos e Muitos-para-muitos:
Use Relationship() com back_populates espelhando o nome do campo do outro lado.

✔️ Quando há duas FKs para a mesma tabela:
Use sa_relationship_kwargs={"foreign_keys": "[Classe.campo]"} para evitar ambiguidade.

🧠 Injeção de Dependências com Depends
O que é?
O FastAPI chama automaticamente funções auxiliares (como get_session()) e injeta o resultado como argumento da função de rota.

Exemplo:

python
def get_session():
    return Session(engine)

@router.get("/")
def listar(session: Session = Depends(get_session)):
    ...
📤 Rotas com FastAPI
Criando um personagem:
python
@router.post("/", status_code=201)
def criar(dados: PersonagemCreate, session: Session = Depends(get_session)):
    novo = Personagem(**dados.dict())
    session.add(novo)
    session.commit()
    session.refresh(novo)
    return novo
Listando todos os personagens:
python
@router.get("/", response_model=List[Personagem])
def listar(session: Session = Depends(get_session)):
    return session.query(Personagem).all()
🧩 Tipagem e clareza
session: Session: é anotação de tipo

Facilita autocomplete, documentação Swagger e leitura

List[Objeto]: indica que a rota retorna uma lista de objetos daquele tipo

Optional[str] = None: campo opcional com valor padrão

🛠️ Dicas bônus
Sempre importe seus models no main.py pra garantir que as tabelas sejam registradas e criadas com create_all()

Nunca repita o nome de um campo (conflitos) em dois lugares com tipos diferentes

Use TYPE_CHECKING quando quiser evitar importações circulares entre modelos

Se quiser, posso gerar isso num .md, .txt ou até transformar em página bonita explicativa depois 😄

Prontinha pra próxima aventura? Vamos codar mais uma funcionalidade? 🚀💻📘


**dados.dict()	Converte um schema em argumentos para criar objeto ORM
response_model=List[...]	Define o formato da resposta da rota
session.query(Model).all()	Consulta todos os registros de uma tabela do banco


Isso aí é a essência do que tá rolando na linha Evento(**dados.dict()). Bora só reforçar com uma explicação bem visual pra cravar de vez esse entendimento:

🚦 Fluxo completo, passo a passo
Usuário envia JSON no corpo da requisição:

json
{
  "nome": "Davi é coroado",
  "descricao": "Unção como rei de Israel"
}
FastAPI converte esse JSON num objeto EventoCreate (um schema Pydantic):

python
dados = EventoCreate(nome="Davi é coroado", descricao="Unção como rei")
.dict() converte esse objeto num dicionário Python:

python
{
  "nome": "Davi é coroado",
  "descricao": "Unção como rei"
}
** desempacota o dicionário em argumentos nomeados:

python
Evento(nome="Davi é coroado", descricao="Unção como rei")
🔄 Esse objeto Evento é do tipo SQLModel, pronto pra ser salvo com:

python
session.add(novo)
session.commit()
🧪 Tradução mental da linha:
python
novo = Evento(**dados.dict())
“Crie um novo Evento, usando os campos recebidos da requisição como argumentos nomeados.”